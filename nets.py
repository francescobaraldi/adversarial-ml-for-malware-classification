import torch
from torch import nn


class Net(nn.Module): 
    def __init__(self, dim_input = 215, layers = [20, 20], dim_output = 1):
        if len(layers) == 0:
            raise Exception
        super(Net, self).__init__()
        modules = [
            nn.Linear(dim_input, layers[0]),
            nn.ReLU()
        ]
        for i in range(len(layers) - 1):
            modules.append(nn.Linear(layers[i], layers[i + 1]))
            modules.append(nn.ReLU())
        modules.append(nn.Linear(layers[len(layers) - 1], dim_output))
        modules.append(nn.Sigmoid())
        self.net = nn.Sequential(*modules)
        
    def forward(self, input_data):
        return self.net(torch.flatten(input_data, 1))
    

def eval_acc(model: nn.Module, data_loader: torch.utils.data.DataLoader):
    correct = 0
    total = 0
    with torch.no_grad():
        for x, y in data_loader:
            y = y.unsqueeze(1).to(torch.float32)
            y_pred = model(x)
            # y_pred = torch.sigmoid(y_pred)
            y_pred_discr = torch.where(y_pred >= 0.5, 1.0, 0.0)
            acc = torch.sum((y_pred_discr == y))
            correct += acc
            total += y.shape[0]
    return correct / total
